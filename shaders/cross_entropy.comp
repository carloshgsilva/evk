#include "evk.frag"

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_atomic_float : enable
#extension GL_EXT_control_flow_attributes : enable

layout(buffer_reference) buffer BufferFp16 { float16_t x[]; };
layout(buffer_reference) buffer BufferU16 { uint16_t x[]; };
layout(buffer_reference) buffer BufferFp32 { float x[]; };

PUSH(
    BufferFp16 logitsBuffer;   // (totalPositions, vocabSize)
    BufferU16 targetBuffer;    // (totalPositions)
    BufferFp16 gradBuffer;     // (totalPositions, vocabSize)
    BufferFp32 accumBuffer;    // float[2] -> {totalLoss, validCount}
    uint vocabSize;            // V
    uint totalPositions;       // B * N
)

// One workgroup (single subgroup) per row
COMPUTE(32, 1, 1)
void main() {
    uint row = gl_WorkGroupID.x;
    if (row >= totalPositions) return;

    uint lid = gl_LocalInvocationID.x; // 0..31
    uint rowStart = row * vocabSize;
    uint targetIdx = uint(targetBuffer.x[row]);
    bool isValidTarget = (targetIdx != 0u);

    // 1) Row-wise max for stability
    float localMax = -3.402823466e+38; // -FLT_MAX
    for (uint j = lid; j < vocabSize; j += 32) {
        float v = float(logitsBuffer.x[rowStart + j]);
        v = clamp(v, -65000.0, 65000.0);
        localMax = max(localMax, v);
    }
    float rowMax = subgroupMax(localMax);

    // 2) Sum of exp
    float localSum = 0.0;
    for (uint j = lid; j < vocabSize; j += 32) {
        float v = float(logitsBuffer.x[rowStart + j]);
        v = clamp(v, -65000.0, 65000.0);
        localSum += exp(v - rowMax);
    }
    float denom = subgroupAdd(localSum);
    float safeDenom = max(denom, 1e-20);
    float invDenom = 1.0 / safeDenom;
    float logDenom = log(safeDenom);

    // 3) Gradients + target log prob
    float targetLogProb = 0.0;
    for (uint j = lid; j < vocabSize; j += 32) {
        float logit = float(logitsBuffer.x[rowStart + j]);
        logit = clamp(logit, -65000.0, 65000.0);
        float softmax_val = exp(logit - rowMax) * invDenom;

        float grad = isValidTarget ? softmax_val : 0.0;
        if (isValidTarget && j == targetIdx) {
            grad -= 1.0;
            targetLogProb = logit - rowMax - logDenom;
        }
        gradBuffer.x[rowStart + j] = float16_t(grad);
    }

    // 4) Accumulate totals using atomics
    if (isValidTarget) {
        float reducedTarget = subgroupAdd(targetLogProb);
        if (lid == 0) {
            atomicAdd(accumBuffer.x[0], -reducedTarget); // total loss
            atomicAdd(accumBuffer.x[1], 1.0);            // valid count
        }
    }
}
