#include "evk.frag"

// Flash Attention v2 forward (MQA) using cooperative matrices (tensor cores).
// Tiled algorithm over (i,j) with online softmax per row. Accumulation goes
// directly into the output buffer, and scratch is used only for the 16x16 P tile.
// Layout (row-major):
// Q,O: (B, N, D) with D = H * Dh (heads concatenated)
// K,V: (B, N, Dh)

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_buffer_reference : enable

CONSTANT(0) uint B = 0u;
CONSTANT(1) uint H = 0u;
CONSTANT(2) uint N = 0u;
CONSTANT(3) uint D = 0u;
CONSTANT(4) float SCALE = 0.0;

layout(buffer_reference) buffer BufferFp16 { float16_t x[]; };

PUSH(
    BufferFp16 qBuf;
    BufferFp16 kBuf;
    BufferFp16 vBuf;
    BufferFp16 oBuf;
    BufferFp16 scratchBuf; // per (b,h,iTile) scratch: [Ptile(16*16)] in fp16
)

#define SUB_TILE 16u
#define TILE_M 16u   // queries per tile
#define TILE_J 16u   // keys per tile

const uint C_ROWS = TILE_M / SUB_TILE; // 1
const uint C_COLS = TILE_J / SUB_TILE; // 1

// Shared tiles to reduce global memory traffic
shared float16_t Psh[TILE_M * TILE_J]; // 16x16 probabilities tile
shared float16_t Dsh[TILE_M * TILE_M]; // 16x16 diagonal scaling matrix per row
// Keep per-kd output sub-tiles in shared memory across j-tiles to avoid
// reading/writing global O every iteration. Supports Dh up to 16*16 = 256.
const uint MAX_KD_TILES = 16u; // max Dh blocks (Dh <= 256)
shared float16_t Osh[MAX_KD_TILES * TILE_M * TILE_M];

// Workgroup maps: (x=1 per kernel), y over query tiles, z over combined (B*H)
COMPUTE(32, 1, 1)
void main() {
    uint Dh = D / H;

    uint tileRow = gl_WorkGroupID.y;                  // i tile index
    uint bh = gl_WorkGroupID.z;                       // combined batch-head
    uint b = bh / H;
    uint h = bh % H;
    if (b >= B) return;

    // Base offsets
    uint baseQ_B = b * (N * D);
    uint baseK_B = b * (N * Dh);
    uint baseV_B = b * (N * Dh);
    uint baseO_B = b * (N * D);

    uint i0 = tileRow * TILE_M;

    // Initialize softmax running stats
    float m[TILE_M];
    float l[TILE_M];
    [[unroll]] for (uint r = 0u; r < TILE_M; ++r) { m[r] = -3.402823466e+38; l[r] = 0.0; }

    // Initialize per-kd shared accumulators to zero
    uint lane = gl_SubgroupInvocationID;
    uint kdTiles = Dh / SUB_TILE;
    if (lane < TILE_M) {
        [[unroll]] for (uint kdIdx = 0u; kdIdx < kdTiles && kdIdx < MAX_KD_TILES; ++kdIdx) {
            [[unroll]] for (uint cc = 0u; cc < TILE_M; ++cc) {
                Osh[kdIdx * (TILE_M * TILE_M) + lane * TILE_M + cc] = float16_t(0.0);
            }
        }
    }
    barrier();

    // Preload Q sub-tiles (per kd) once for this (i0,h) tile to avoid reloading every j0
    uint kdTilesClamped = (kdTiles < MAX_KD_TILES) ? kdTiles : MAX_KD_TILES;
    coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> qMats[MAX_KD_TILES];
    for (uint k0 = 0u, kdIdx = 0u; kdIdx < kdTilesClamped; ++kdIdx, k0 += SUB_TILE) {
        uint qOff = baseQ_B + (i0 * D) + (h * Dh) + k0; // top-left of Q tile for this kd
        coopMatLoad(qMats[kdIdx], qBuf.x, qOff, D, gl_CooperativeMatrixLayoutRowMajor);
    }

    // Loop over key tiles j0
    for (uint j0 = 0u; j0 < N; j0 += TILE_J) {
        // Compute S_block (16x16) = Q_tile(16xDh) * K_tile^T(Dh x 16)
        coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> sTile =
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator>(0.0);

        for (uint k0 = 0u, kdIdx = 0u; k0 < Dh; k0 += SUB_TILE, ++kdIdx) {
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> kMat;
            uint kOff = baseK_B + (j0 * Dh) + k0;           // top-left of K tile (column-major view)
            coopMatLoad(kMat, kBuf.x, kOff, Dh, gl_CooperativeMatrixLayoutColumnMajor);

            sTile = coopMatMulAdd(qMats[kdIdx], kMat, sTile);
        }

        // Store S_block into shared P tile (row-major, stride TILE_J)
        coopMatStore(sTile, Psh, 0u, TILE_J, gl_CooperativeMatrixLayoutRowMajor);

        // Row-wise online softmax and scaling prep in parallel across subgroup lanes
        if (lane < TILE_M) {
            // Compute new max for this row
            float m_new = m[lane];
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
            float s = float(Psh[lane * TILE_J + c]) * SCALE;
                m_new = max(m_new, s);
            }
            // Compute new denom and overwrite Ptile row with exp(s - m_new)
            float l_new = l[lane] * exp(m[lane] - m_new);
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
            float s = float(Psh[lane * TILE_J + c]) * SCALE;
                float w = exp(s - m_new);
                l_new += w;
                Psh[lane * TILE_J + c] = float16_t(w);
            }

            // Compute old_scale and write diagonal
            float old_scale = (l[lane] <= 0.0) ? 0.0 : ((l[lane] * exp(m[lane] - m_new)) / max(l_new, 1e-20));
            Dsh[lane * TILE_M + lane] = float16_t(old_scale);

            // Row normalization
            float inv_l = 1.0 / max(l_new, 1e-20);
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
                float w = float(Psh[lane * TILE_J + c]);
                Psh[lane * TILE_J + c] = float16_t(w * inv_l);
            }
            m[lane] = m_new;
            l[lane] = l_new;
        }
        barrier();

        // Fused: For each kd tile, scale O by Dsh and add P*V
        coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> pMat;
        coopMatLoad(pMat, Psh, 0u, TILE_J, gl_CooperativeMatrixLayoutRowMajor);
        coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> dMat;
        coopMatLoad(dMat, Dsh, 0u, TILE_M, gl_CooperativeMatrixLayoutRowMajor);

        for (uint kd0 = 0u, kdIdx = 0u; kd0 < Dh; kd0 += SUB_TILE, ++kdIdx) {
            // Load V tile for this kd
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> vMat;
            uint vOff = baseV_B + (j0 * Dh) + kd0; // top-left (j0,kd0)
            coopMatLoad(vMat, vBuf.x, vOff, Dh, gl_CooperativeMatrixLayoutRowMajor);

            // Load current O accumulator from shared memory
            uint oShOff = kdIdx * (TILE_M * TILE_M);
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> oAccB;
            coopMatLoad(oAccB, Osh, oShOff, TILE_M, gl_CooperativeMatrixLayoutRowMajor);

            // tmp = Dsh * oAcc; then oAcc = tmp + P * V
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> tmpAcc =
                coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator>(0.0);
            tmpAcc = coopMatMulAdd(dMat, oAccB, tmpAcc);
            tmpAcc = coopMatMulAdd(pMat, vMat, tmpAcc);
            coopMatStore(tmpAcc, Osh, oShOff, TILE_M, gl_CooperativeMatrixLayoutRowMajor);
        }
    }

    // After processing all j tiles, write final O from shared accumulators to global
    for (uint kd0 = 0u, kdIdx = 0u; kd0 < Dh; kd0 += SUB_TILE, ++kdIdx) {
        uint oShOff = kdIdx * (TILE_M * TILE_M);
        coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> oAccFinal;
        coopMatLoad(oAccFinal, Osh, oShOff, TILE_M, gl_CooperativeMatrixLayoutRowMajor);
        uint oSubOff = baseO_B + (i0 * D) + (h * Dh) + kd0;
        coopMatStore(oAccFinal, oBuf.x, oSubOff, D, gl_CooperativeMatrixLayoutRowMajor);
    }
}
