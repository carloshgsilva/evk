#include "evk.frag"

// Flash Attention v2 forward (MQA) using cooperative matrices (tensor cores).
// Tiled algorithm over (i,j) with online softmax per row using a small scratch tile.
// Tiles size should match the QKV size.
// Layout (row-major):
// Q,O: (B, N, D) with D = H * Dh (heads concatenated)
// K,V: (B, N, Dh)

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_buffer_reference : enable

layout(buffer_reference) buffer BufferFp16 { float16_t x[]; };

PUSH(
    BufferFp16 qBuf;
    BufferFp16 kBuf;
    BufferFp16 vBuf;
    BufferFp16 oBuf;
    BufferFp16 scratchBuf; // per (b,h,iTile) scratch: [Otile(16*Dh) | Ptile(16*16)] in fp16
    uint B;
    uint H;
    uint N;
    uint D;
    float scale; // 1/sqrt(Dh)
)

#define SUB_TILE 16u
#define TILE_M 16u   // queries per tile
#define TILE_J 16u   // keys per tile

const uint C_ROWS = TILE_M / SUB_TILE; // 1
const uint C_COLS = TILE_J / SUB_TILE; // 1

// Workgroup maps: (x=1 per kernel), y over query tiles, z over combined (B*H)
COMPUTE(32, 1, 1)
void main() {
    uint Dh = D / H;

    uint tileRow = gl_WorkGroupID.y;                  // i tile index
    uint bh = gl_WorkGroupID.z;                       // combined batch-head
    uint b = bh / H;
    uint h = bh % H;
    if (b >= B) return;

    // Base offsets
    uint baseQ_B = b * (N * D);
    uint baseK_B = b * (N * Dh);
    uint baseV_B = b * (N * Dh);
    uint baseO_B = b * (N * D);

    uint i0 = tileRow * TILE_M;

    // Scratch layout per tile: first Otile (TILE_M x Dh), then Ptile (TILE_M x TILE_J)
    uint tilesPerBH = N / TILE_M;
    uint tileLinear = (bh * tilesPerBH) + tileRow;
    uint otileCount = TILE_M * Dh;            // fp16 elements
    uint ptileCount = TILE_M * TILE_J;        // fp16 elements
    uint scratchPerTile = otileCount + ptileCount;
    uint scratchBase = tileLinear * scratchPerTile;
    uint otileBase = scratchBase;             // [TILE_M x Dh], row-major, stride Dh
    uint ptileBase = scratchBase + otileCount;// [TILE_M x TILE_J], row-major, stride TILE_J

    // Initialize softmax running stats
    float m[TILE_M];
    float l[TILE_M];
    [[unroll]] for (uint r = 0u; r < TILE_M; ++r) { m[r] = -3.402823466e+38; l[r] = 0.0; }

    // Initialize Otile to zeros
    for (uint kd = 0u; kd < Dh; ++kd) {
        for (uint r = 0u; r < TILE_M; ++r) {
            scratchBuf.x[otileBase + r * Dh + kd] = float16_t(0.0);
        }
    }

    // Loop over key tiles j0
    for (uint j0 = 0u; j0 < N; j0 += TILE_J) {
        // Compute S_block (16x16) = Q_tile(16xDh) * K_tile^T(Dh x 16)
        coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> sTile =
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator>(0.0);

        for (uint k0 = 0u; k0 < Dh; k0 += SUB_TILE) {
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> qMat;
            uint qOff = baseQ_B + (i0 * D) + (h * Dh) + k0; // top-left of Q tile
            coopMatLoad(qMat, qBuf.x, qOff, D, gl_CooperativeMatrixLayoutRowMajor);

            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> kMat;
            uint kOff = baseK_B + (j0 * Dh) + k0;           // top-left of K tile (column-major view)
            coopMatLoad(kMat, kBuf.x, kOff, Dh, gl_CooperativeMatrixLayoutColumnMajor);

            sTile = coopMatMulAdd(qMat, kMat, sTile);
        }

        // Store S_block into Ptile scratch temporarily
        // Stride for Ptile rows is TILE_J half-elements
        coopMatStore(sTile, scratchBuf.x, ptileBase, TILE_J, gl_CooperativeMatrixLayoutRowMajor);

        // Row-wise online softmax update, write normalized Ptile back into same Ptile region
        for (uint r = 0u; r < TILE_M; ++r) {
            // Compute new max
            float m_new = m[r];
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
                float s = float(scratchBuf.x[ptileBase + r * TILE_J + c]) * scale;
                m_new = max(m_new, s);
            }
            // Compute new denom and overwrite Ptile with exp(s - m_new)
            float l_new = l[r] * exp(m[r] - m_new);
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
                float s = float(scratchBuf.x[ptileBase + r * TILE_J + c]) * scale;
                float w = exp(s - m_new);
                l_new += w;
                scratchBuf.x[ptileBase + r * TILE_J + c] = float16_t(w);
            }

            // Scale previous Otile row by old_scale = (l_old * exp(m_old - m_new)) / l_new
            float old_scale = (l[r] <= 0.0) ? 0.0 : ((l[r] * exp(m[r] - m_new)) / max(l_new, 1e-20));
            for (uint kd = 0u; kd < Dh; ++kd) {
                float prev = float(scratchBuf.x[otileBase + r * Dh + kd]);
                scratchBuf.x[otileBase + r * Dh + kd] = float16_t(prev * old_scale);
            }
            // Normalize Ptile row by l_new
            float inv_l = 1.0 / max(l_new, 1e-20);
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
                float w = float(scratchBuf.x[ptileBase + r * TILE_J + c]);
                scratchBuf.x[ptileBase + r * TILE_J + c] = float16_t(w * inv_l);
            }
            m[r] = m_new;
            l[r] = l_new;
        }

        // Accumulate Otile += Ptile(16x16) * Vtile(16xDh)
        for (uint kd0 = 0u; kd0 < Dh; kd0 += SUB_TILE) {
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> pMat;
            coopMatLoad(pMat, scratchBuf.x, ptileBase, TILE_J, gl_CooperativeMatrixLayoutRowMajor);

            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> vMat;
            uint vOff = baseV_B + (j0 * Dh) + kd0; // top-left (j0,kd0)
            coopMatLoad(vMat, vBuf.x, vOff, Dh, gl_CooperativeMatrixLayoutRowMajor);

            // Load current Otile sub-block as accumulator
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> oSub;
            uint oSubOff = otileBase + kd0; // row 0, col kd0
            coopMatLoad(oSub, scratchBuf.x, oSubOff, Dh, gl_CooperativeMatrixLayoutRowMajor);

            oSub = coopMatMulAdd(pMat, vMat, oSub);
            coopMatStore(oSub, scratchBuf.x, oSubOff, Dh, gl_CooperativeMatrixLayoutRowMajor);
        }
    }

    // Write Otile to output O
    for (uint r = 0u; r < TILE_M; ++r) {
        uint i = i0 + r;
        if (i >= N) break;
        uint oRowHead = baseO_B + i * D + h * Dh;
        for (uint kd = 0u; kd < Dh; ++kd) {
            oBuf.x[oRowHead + kd] = scratchBuf.x[otileBase + r * Dh + kd];
        }
    }
}
