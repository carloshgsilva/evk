#include "evk.frag"

// Flash Attention v2 forward (MQA) using cooperative matrices (tensor cores).
// Tiled algorithm over (i,j) with online softmax per row. Accumulation goes
// directly into the output buffer, and scratch is used only for the 16x16 P tile.
// Layout (row-major):
// Q,O: (B, N, D) with D = H * Dh (heads concatenated)
// K,V: (B, N, Dh)

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_buffer_reference : enable

layout(buffer_reference) buffer BufferFp16 { float16_t x[]; };

PUSH(
    BufferFp16 qBuf;
    BufferFp16 kBuf;
    BufferFp16 vBuf;
    BufferFp16 oBuf;
    BufferFp16 scratchBuf; // per (b,h,iTile) scratch: [Ptile(16*16)] in fp16
    uint B;
    uint H;
    uint N;
    uint D;
    float scale; // 1/sqrt(Dh)
)

#define SUB_TILE 16u
#define TILE_M 16u   // queries per tile
#define TILE_J 16u   // keys per tile

const uint C_ROWS = TILE_M / SUB_TILE; // 1
const uint C_COLS = TILE_J / SUB_TILE; // 1

// Shared tiles to reduce global memory traffic
shared float16_t Psh[TILE_M * TILE_J]; // 16x16 probabilities tile
shared float16_t Dsh[TILE_M * TILE_M]; // 16x16 diagonal scaling matrix per row

// Workgroup maps: (x=1 per kernel), y over query tiles, z over combined (B*H)
COMPUTE(32, 1, 1)
void main() {
    uint Dh = D / H;

    uint tileRow = gl_WorkGroupID.y;                  // i tile index
    uint bh = gl_WorkGroupID.z;                       // combined batch-head
    uint b = bh / H;
    uint h = bh % H;
    if (b >= B) return;

    // Base offsets
    uint baseQ_B = b * (N * D);
    uint baseK_B = b * (N * Dh);
    uint baseV_B = b * (N * Dh);
    uint baseO_B = b * (N * D);

    uint i0 = tileRow * TILE_M;

    // Initialize softmax running stats
    float m[TILE_M];
    float l[TILE_M];
    [[unroll]] for (uint r = 0u; r < TILE_M; ++r) { m[r] = -3.402823466e+38; l[r] = 0.0; }

    // Loop over key tiles j0
    for (uint j0 = 0u; j0 < N; j0 += TILE_J) {
        // Compute S_block (16x16) = Q_tile(16xDh) * K_tile^T(Dh x 16)
        coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> sTile =
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator>(0.0);

        for (uint k0 = 0u; k0 < Dh; k0 += SUB_TILE) {
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> qMat;
            uint qOff = baseQ_B + (i0 * D) + (h * Dh) + k0; // top-left of Q tile
            coopMatLoad(qMat, qBuf.x, qOff, D, gl_CooperativeMatrixLayoutRowMajor);

            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> kMat;
            uint kOff = baseK_B + (j0 * Dh) + k0;           // top-left of K tile (column-major view)
            coopMatLoad(kMat, kBuf.x, kOff, Dh, gl_CooperativeMatrixLayoutColumnMajor);

            sTile = coopMatMulAdd(qMat, kMat, sTile);
        }

        // Store S_block into shared P tile (row-major, stride TILE_J)
        coopMatStore(sTile, Psh, 0u, TILE_J, gl_CooperativeMatrixLayoutRowMajor);

        // Row-wise online softmax and scaling prep in parallel across subgroup lanes
        uint lane = gl_SubgroupInvocationID;
        if (lane < TILE_M) {
            // Zero this row of Dsh
            [[unroll]] for (uint cc = 0u; cc < TILE_M; ++cc) { Dsh[lane * TILE_M + cc] = float16_t(0.0); }

            // Compute new max for this row
            float m_new = m[lane];
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
                float s = float(Psh[lane * TILE_J + c]) * scale;
                m_new = max(m_new, s);
            }
            // Compute new denom and overwrite Ptile row with exp(s - m_new)
            float l_new = l[lane] * exp(m[lane] - m_new);
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
                float s = float(Psh[lane * TILE_J + c]) * scale;
                float w = exp(s - m_new);
                l_new += w;
                Psh[lane * TILE_J + c] = float16_t(w);
            }

            // Compute old_scale and write diagonal
            float old_scale = (l[lane] <= 0.0) ? 0.0 : ((l[lane] * exp(m[lane] - m_new)) / max(l_new, 1e-20));
            Dsh[lane * TILE_M + lane] = float16_t(old_scale);

            // Row normalization
            float inv_l = 1.0 / max(l_new, 1e-20);
            [[unroll]] for (uint c = 0u; c < TILE_J; ++c) {
                float w = float(Psh[lane * TILE_J + c]);
                Psh[lane * TILE_J + c] = float16_t(w * inv_l);
            }
            m[lane] = m_new;
            l[lane] = l_new;
        }
        barrier();

        // Ensure shared-memory writes are visible before cooperative loads
        barrier();

        // Fused: For each kd tile, scale O by Dsh and add P*V
        for (uint kd0 = 0u; kd0 < Dh; kd0 += SUB_TILE) {
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> pMat;
            coopMatLoad(pMat, Psh, 0u, TILE_J, gl_CooperativeMatrixLayoutRowMajor);

            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> vMat;
            uint vOff = baseV_B + (j0 * Dh) + kd0; // top-left (j0,kd0)
            coopMatLoad(vMat, vBuf.x, vOff, Dh, gl_CooperativeMatrixLayoutRowMajor);

            // Load diagonal scaling matrix Dsh and current O sub-block
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> dMat;
            coopMatLoad(dMat, Dsh, 0u, TILE_M, gl_CooperativeMatrixLayoutRowMajor);

            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> oSubB;
            uint oSubOff = baseO_B + (i0 * D) + (h * Dh) + kd0; // row i0, col kd0 within head slice
            coopMatLoad(oSubB, oBuf.x, oSubOff, D, gl_CooperativeMatrixLayoutRowMajor);

            // Scale existing O by Dsh and add new contribution
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> acc0 =
                coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator>(0.0);
            acc0 = coopMatMulAdd(dMat, oSubB, acc0);
            acc0 = coopMatMulAdd(pMat, vMat, acc0);
            coopMatStore(acc0, oBuf.x, oSubOff, D, gl_CooperativeMatrixLayoutRowMajor);
        }
    }
}
