#include "evk.frag"

// Cooperative tiled matrix multiplication kernel
// Doesn't have bounds check, assumes 16x16 (TILE_M and TILE_N are divisible by 16)

CONSTANT(0) uint M = 0;
CONSTANT(1) uint K = 0;
CONSTANT(2) uint N = 0;
CONSTANT(3) uint TILE_M = 0;
CONSTANT(4) uint TILE_N = 0;
CONSTANT(5) uint ACC_C = 0;
CONSTANT(6) uint TRANSPOSE_A = 0;
CONSTANT(7) uint TRANSPOSE_B = 0;
CONSTANT(8) uint STRIDE_A = 0; // elements per batch for A (0 => broadcast)
CONSTANT(9) uint STRIDE_B = 0; // elements per batch for B (0 => broadcast)
CONSTANT(10) uint STRIDE_C = 0; // elements per batch for C

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_control_flow_attributes : enable
#extension GL_EXT_buffer_reference : enable

layout(buffer_reference) buffer BufferFp16 { float16_t x[]; };

PUSH(
    BufferFp16 inputA;
    BufferFp16 inputB;
    BufferFp16 inputC;
)

#define TILE_K 16
#define SUB_TILE 16

const uint C_ROWS = TILE_M / SUB_TILE;
const uint C_COLS = TILE_N / SUB_TILE;
coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> result[C_ROWS][C_COLS];

uint coordToOffset(uint i, uint j, uint stride, bool colMajor) {
    return colMajor ? (stride * j + i) : (stride * i + j);
}

COMPUTE(32, 1, 1)
void main() {
    uvec2 tileID = uvec2(gl_WorkGroupID.xy);
    uint batchID = gl_WorkGroupID.z;

    // Compute base element offsets for this batch, allowing broadcast (stride == 0)
    uint baseA = (STRIDE_A == 0u) ? 0u : batchID * STRIDE_A;
    uint baseB = (STRIDE_B == 0u) ? 0u : batchID * STRIDE_B;
    uint baseC = (STRIDE_C == 0u) ? 0u : batchID * STRIDE_C;

    // Initialize result to zero
    [[unroll]] for (uint i = 0; i < C_ROWS; ++i) {
        [[unroll]] for (uint j = 0; j < C_COLS; ++j) {
            result[i][j] = coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator>(0.0);
        }
    }

    // Accumulate result for each chunk of K
    for (uint chunkK = 0; chunkK < K; chunkK += TILE_K) {
        coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> matB;
        [[unroll]] for (uint i = 0; i < C_ROWS; ++i) {
            uint gi = TILE_M * tileID.y + SUB_TILE * i;
            uint gk = chunkK;

            // Load matA
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> matA;
            if (STRIDE_A != 0u) {
                if (TRANSPOSE_A != 0u) {
                    coopMatLoad(matA, inputA.x, baseA + coordToOffset(gi, gk, M, true), M, gl_CooperativeMatrixLayoutColumnMajor);
                } else {
                    coopMatLoad(matA, inputA.x, baseA + coordToOffset(gi, gk, K, false), K, gl_CooperativeMatrixLayoutRowMajor);
                }
            }
            if (STRIDE_A == 0u) {
                if (TRANSPOSE_A != 0u) {
                    coopMatLoad(matA, inputA.x, coordToOffset(gi, gk, M, true), M, gl_CooperativeMatrixLayoutColumnMajor);
                } else {
                    coopMatLoad(matA, inputA.x, coordToOffset(gi, gk, K, false), K, gl_CooperativeMatrixLayoutRowMajor);
                }
            }

            // Loop over each column of matB
            [[unroll]] for (uint j = 0; j < C_COLS; ++j) {
                uint gj = TILE_N * tileID.x + SUB_TILE * j;
                uint gk = chunkK;

                // Load matB
                if (STRIDE_B != 0u) {
                    if (TRANSPOSE_B != 0u) {
                        coopMatLoad(matB, inputB.x, baseB + coordToOffset(gk, gj, K, true), K, gl_CooperativeMatrixLayoutColumnMajor);
                    } else {
                        coopMatLoad(matB, inputB.x, baseB + coordToOffset(gk, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                    }
                }
                if (STRIDE_B == 0u) {
                    if (TRANSPOSE_B != 0u) {
                        coopMatLoad(matB, inputB.x, coordToOffset(gk, gj, K, true), K, gl_CooperativeMatrixLayoutColumnMajor);
                    } else {
                        coopMatLoad(matB, inputB.x, coordToOffset(gk, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                    }
                }
                result[i][j] = coopMatMulAdd(matA, matB, result[i][j]);
            }
        }
    }

    // Store the result
    [[unroll]] for (uint i = 0; i < C_ROWS; ++i) {
        [[unroll]] for (uint j = 0; j < C_COLS; ++j) {
            uint gi = TILE_M * tileID.y + SUB_TILE * i;
            uint gj = TILE_N * tileID.x + SUB_TILE * j;

            if (ACC_C == 0u) {
                if (STRIDE_C != 0u) {
                    coopMatStore(result[i][j], inputC.x, baseC + coordToOffset(gi, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                }
                if (STRIDE_C == 0u) {
                    coopMatStore(result[i][j], inputC.x, coordToOffset(gi, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                }
            } else {
                coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> mat_c;
                if (STRIDE_C != 0u) {
                    coopMatLoad(mat_c, inputC.x, baseC + coordToOffset(gi, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                }
                if (STRIDE_C == 0u) {
                    coopMatLoad(mat_c, inputC.x, coordToOffset(gi, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                }
                result[i][j] = result[i][j] + mat_c;
                if (STRIDE_C != 0u) {
                    coopMatStore(result[i][j], inputC.x, baseC + coordToOffset(gi, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                }
                if (STRIDE_C == 0u) {
                    coopMatStore(result[i][j], inputC.x, coordToOffset(gi, gj, N, false), N, gl_CooperativeMatrixLayoutRowMajor);
                }
            }
        }
    }
}