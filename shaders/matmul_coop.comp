#include "evk.frag"

CONSTANT(0) uint TRANSPOSE_A = 0;
CONSTANT(1) uint SUM_C = 0;

PUSH(
    int aBufferRID;
    int bBufferRID;
    int cBufferRID;
    uint B; // B = batch size (optional, set to 1 if unused)
    uint M; // M = rows of A / output rows
    uint K; // K = shared dimension (columns of A / rows of B)
    uint N; // N = columns of B / output columns
)

BINDING_BUFFER_RW(float_buffer,
    float at[];
)

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_KHR_cooperative_matrix : enable
#extension GL_KHR_memory_scope_semantics : enable

// Workgroup configuration - optimized for shared memory cooperative matrix operations
#define TILE_K 128
#define TILE_M 128
#define TILE_N 128
#define SUB_TILE 16

// Shared memory with padding to avoid bank conflicts (similar to shmem.comp approach)
// Using optimized loading pattern with better memory access
#define ROW_PAD 2  // Pad each row by 2 elements to avoid bank conflicts
shared float16_t Asub[TILE_M * (TILE_K + ROW_PAD)];
shared float16_t Bsub[TILE_N * (TILE_K + ROW_PAD)];

COMPUTE(1024, 1, 1)
void main() {
    // Workgroup mapping (host dispatch: X = tilesCols, Y = tilesRows, Z = batch)
    uint tilesRows = (M + TILE_M - 1u) / TILE_M;
    uint tilesCols = (N + TILE_N - 1u) / TILE_N;
    uint batchIdx = gl_WorkGroupID.z;
    uint tileRowIndex = gl_WorkGroupID.y;
    uint tileColIndex = gl_WorkGroupID.x;

    uint aBase = batchIdx * (M * K);
    uint bBase = batchIdx * (K * N);
    uint cBase = batchIdx * (M * N);

    // 32x32 tile origin for this workgroup
    uint tileRow0 = tileRowIndex * TILE_M;
    uint tileCol0 = tileColIndex * TILE_N;

    // Subgroup configuration - optimized for better memory access patterns
    uint subgroupIdx = gl_SubgroupID;
    uint subgroupsPerRow = 8u;  // 128/16 = 8 subgroups per row
    uint subTileRow = subgroupIdx / subgroupsPerRow;        // 0-7
    uint subTileCol = subgroupIdx % subgroupsPerRow;        // 0-7
    uint subTileRow0 = tileRow0 + subTileRow * SUB_TILE;
    uint subTileCol0 = tileCol0 + subTileCol * SUB_TILE;

    // Per-subgroup accumulator (16x16)
    coopmat<float, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> accumulator =
        coopmat<float, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator>(0.0);

    // Process K dimension in tiles
    for (uint kTile0 = 0; kTile0 < K; kTile0 += TILE_K) {
        // Load A and B tiles into shared memory with optimized access patterns
        // Each thread loads multiple elements to maximize memory bandwidth

        // Calculate linear thread index within workgroup (0-575)
        uint threadIdx = gl_LocalInvocationIndex;

        // Load A tile: optimized loading pattern with better memory access
        uint elementsPerThread = (TILE_M * TILE_K + 1023u) / 1024u; // Ceiling division
        for (uint elem = 0u; elem < elementsPerThread; elem++) {
            uint i = threadIdx + elem * 1024u;
            uint row = i / TILE_K;
            uint col = i % TILE_K;

            uint aRow = tileRow0 + row;
            uint aCol = kTile0 + col;

            float16_t aVal = float16_t(0.0);

            // No bounds check (assumes it's always aligned)
            uint aIndex;
            if (TRANSPOSE_A == 0u) {
                // A as MxK row-major
                aIndex = aBase + aRow * K + aCol;
            } else {
                // A stored transposed as KxM row-major
                aIndex = aBase + aCol * M + aRow;
            }
            aVal = float16_t(float_buffer[aBufferRID].at[aIndex]);

            // Store in shared memory with padding to avoid bank conflicts
            uint sharedRow = row;
            uint sharedCol = col;
            Asub[sharedRow * (TILE_K + ROW_PAD) + sharedCol] = aVal;
        }

        // Load B tile: optimized loading pattern with better memory access
        elementsPerThread = (TILE_K * TILE_N + 1023u) / 1024u; // Ceiling division
        for (uint elem = 0u; elem < elementsPerThread; elem++) {
            uint i = threadIdx + elem * 1024u;
            uint row = i / TILE_N;
            uint col = i % TILE_N;

            uint bRow = kTile0 + row;
            uint bCol = tileCol0 + col;

            float16_t bVal = float16_t(0.0);

            // Bounds-safe load with zero padding
            uint bIndex = bBase + bRow * N + bCol; // B as KxN row-major
            bVal = float16_t(float_buffer[bBufferRID].at[bIndex]);

            // Store in shared memory with padding to avoid bank conflicts
            uint sharedRow = row;
            uint sharedCol = col;
            Bsub[sharedRow * (TILE_N + ROW_PAD) + sharedCol] = bVal;
        }

        // Ensure all data is loaded before computation
        barrier();

        // Process this K tile in 32-wide steps for better data reuse
        for (uint kInner = 0u; kInner < TILE_K; kInner += 32u) {
            // Load 16x16 fragments from shared memory for this subgroup's subtile
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseA> tile_A;
            coopmat<float16_t, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseB> tile_B;

            // Calculate shared memory offsets for this subtile
            uint aSharedBase = (subTileRow * SUB_TILE) * (TILE_K + ROW_PAD) + kInner;
            uint bSharedBase = kInner * (TILE_N + ROW_PAD) + (subTileCol * SUB_TILE);

            coopMatLoad(tile_A, Asub, aSharedBase, TILE_K + ROW_PAD, 0);
            coopMatLoad(tile_B, Bsub, bSharedBase, TILE_N + ROW_PAD, 0);

            // FMA accumulate 16x16
            accumulator = coopMatMulAdd(tile_A, tile_B, accumulator);
        }

        // Wait before overwriting shared tiles in next K block
        barrier();
    }

    // Store the resulting 16x16 subtile into C
    uint cElement = cBase + subTileRow0 * N + subTileCol0;
    uint cStride = N;
    if (SUM_C == 0u) {
        coopMatStore(accumulator, float_buffer[cBufferRID].at, cElement, cStride, 0);
    } else {
        coopmat<float, gl_ScopeSubgroup, SUB_TILE, SUB_TILE, gl_MatrixUseAccumulator> cTile;
        coopMatLoad(cTile, float_buffer[cBufferRID].at, cElement, cStride, 0);
        cTile = cTile + accumulator;
        coopMatStore(cTile, float_buffer[cBufferRID].at, cElement, cStride, 0);
    }
}