#include "evk.frag"

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_shader_16bit_storage : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable

layout(buffer_reference) buffer BufferFp16 { float16_t x[]; };

PUSH(
    BufferFp16 probsBuffer;     // softmax output
    BufferFp16 gradOutBuffer;   // grad from upstream (grad_probs)
    BufferFp16 gradInBuffer;    // grad to scores (output)
    float scale;                // additional scale factor (e.g., attn_scale)
    uint lastDim;               // row length
    uint outerCount;            // number of rows = totalElements / lastDim
)

// Softmax backward with scale: grad_in = probs * (grad_out - dot(grad_out, probs)) * scale
// One workgroup per row, single subgroup (size 32)
COMPUTE(32, 1, 1)
void main() {
    uint row = gl_WorkGroupID.x;
    if (row >= outerCount) return;

    uint lid = gl_LocalInvocationID.x; // 0..31
    uint rowStart = row * lastDim;

    // 1) Compute dot product: sum(grad_out * probs)
    float localDot = 0.0;
    for (uint j = lid; j < lastDim; j += 32) {
        float p = float(probsBuffer.x[rowStart + j]);
        float g = float(gradOutBuffer.x[rowStart + j]);
        localDot += p * g;
    }
    float dotProd = subgroupAdd(localDot);

    // 2) Compute grad_in = probs * (grad_out - dotProd) * scale
    for (uint j = lid; j < lastDim; j += 32) {
        float p = float(probsBuffer.x[rowStart + j]);
        float g = float(gradOutBuffer.x[rowStart + j]);
        float grad = p * (g - dotProd) * scale;
        gradInBuffer.x[rowStart + j] = float16_t(grad);
    }
}
